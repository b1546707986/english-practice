<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è‹±è¯­å¥å­ç»ƒä¹  - ç§»åŠ¨é€‚é…ç‰ˆ</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; background-color: #fff; display: flex; justify-content: center; align-items: center; height: 100vh; color: #333; overflow: hidden; -webkit-tap-highlight-color: transparent; }
        .app-container { width: 100%; max-width: 900px; height: 100vh; display: flex; flex-direction: column; padding: 20px; box-sizing: border-box; position: relative; }
        
        /* é¡¶éƒ¨æ  */
        .top-bar { 
            display: flex; justify-content: space-between; align-items: center; 
            padding: 10px 0; color: #999; font-size: 14px; 
            height: 40px; flex-shrink: 0;
        }
        .tools { display: flex; gap: 8px; }
        .tool-btn {
            background: #fff; border: 1px solid #ddd; padding: 6px 12px; cursor: pointer; border-radius: 4px; font-size: 12px; color: #666; transition: all 0.2s;
        }
        .tool-btn.primary { background: #54a0ff; color: #fff; border-color: #54a0ff; }

        /* å†…å®¹åŒº */
        .content { 
            flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; 
            overflow-y: auto; /* é˜²æ­¢å†…å®¹è¿‡å¤šæº¢å‡º */
            width: 100%;
        }

        /* å­—ä½“å“åº”å¼è°ƒæ•´ */
        .chinese { font-size: 32px; font-weight: 500; margin-bottom: 15px; color: #2c3e50; text-align: center; }
        .phonetic { color: #95a5a6; font-family: Consolas, monospace; font-size: 16px; margin-bottom: 40px; }
        
        /* æ ¸å¿ƒå¡«ç©ºåŒº */
        .sentence-area { 
            display: flex; justify-content: center; align-items: flex-end; flex-wrap: wrap; 
            gap: 30px; /* PCç«¯é—´è· */
            min-height: 60px; margin-bottom: 20px; width: 100%;
        }
        
        .word-wrapper { position: relative; display: flex; flex-direction: column; align-items: center; }

        .ghost-text {
            position: absolute; bottom: 4px; left: 0; width: 100%; text-align: center; font-size: 28px;
            color: #e0e0e0; font-weight: bold; pointer-events: none; opacity: 0; transition: opacity 0.2s; z-index: 0;
        }
        .ghost-text.show { opacity: 1; }

        .word-input {
            position: relative; z-index: 1; background: transparent; border: none; border-bottom: 3px solid #e0e0e0; 
            font-size: 28px; text-align: center; color: #333; outline: none; padding-bottom: 4px; 
            font-family: inherit; transition: all 0.2s; border-radius: 0; font-weight: 600;
            min-width: 30px;
        }
        .word-input:focus { border-bottom-color: #54a0ff; }
        .word-input.error { color: #ff6b6b; border-bottom-color: #ff6b6b; }
        .word-input.correct { color: #1dd1a1; border-bottom-color: #1dd1a1; }
        /* å·çœ‹æ¨¡å¼ï¼šé€æ˜ */
        .word-input.peeking { color: transparent !important; caret-color: transparent; border-bottom-color: rgba(0,0,0,0.1); }

        /* æˆåŠŸæŒ‰é’® */
        .success-area { height: 60px; display: flex; align-items: center; justify-content: center; margin-top: 20px; }
        .next-btn {
            background-color: #f5f5f5; border: 1px solid #e0e0e0; padding: 12px 60px; font-size: 16px; 
            color: #666; border-radius: 8px; cursor: pointer; transition: all 0.2s;
        }
        .next-btn:active, .next-btn:hover { background-color: #e8e8e8; color: #333; }

        /* --- ç§»åŠ¨ç«¯è§¦æ§æ“ä½œæ  (æ‰‹æœºä¸Šæ˜¾ç¤ºï¼ŒPCéšè—) --- */
        .mobile-controls {
            display: none; /* é»˜è®¤éšè— */
            width: 100%;
            padding: 10px 0;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        .m-btn {
            flex: 1; min-width: 60px; height: 44px; border: 1px solid #eee; background: #fff; border-radius: 8px;
            font-size: 14px; font-weight: bold; color: #555; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05); user-select: none;
        }
        .m-btn:active { background: #f0f0f0; transform: translateY(1px); }
        .m-btn.peek-btn { background: #fff3cd; border-color: #ffeeba; color: #856404; } /* é»„è‰²æŒ‰ä½çœ‹ */

        /* åº•éƒ¨è¯´æ˜ (PCæ˜¾ç¤º) */
        .footer { display: flex; justify-content: center; gap: 15px; color: #aaa; font-size: 12px; margin-top: auto; }
        .key-btn { background: #f1f2f6; padding: 4px 10px; border-radius: 4px; font-weight: bold; color: #555; }

        /* --- åª’ä½“æŸ¥è¯¢ï¼šé’ˆå¯¹æ‰‹æœºå±å¹•è°ƒæ•´ --- */
        @media (max-width: 600px) {
            .chinese { font-size: 24px; margin-bottom: 10px; }
            .phonetic { font-size: 14px; margin-bottom: 20px; }
            
            /* ç¼©å°å¡«ç©ºåŒºåŸŸ */
            .sentence-area { gap: 15px; margin-bottom: 10px; }
            .word-input, .ghost-text { font-size: 20px; border-bottom-width: 2px; }
            
            /* éšè—PCåº•éƒ¨æç¤ºï¼Œæ˜¾ç¤ºæ‰‹æœºæ§åˆ¶æ  */
            .footer { display: none; } 
            .mobile-controls { display: flex; }
            
            /* é¡¶éƒ¨æ è°ƒæ•´ */
            .top-bar { flex-direction: column; height: auto; gap: 10px; align-items: flex-start; }
            .tools { width: 100%; justify-content: space-between; }
            .tool-btn { padding: 8px 12px; flex: 1; text-align: center; }
        }
    </style>
</head>
<body>

<div id="app" class="app-container">
    <div class="top-bar">
        <div style="font-weight: bold; color: #555;">{{ currentIndex + 1 }} / {{ sentenceList.length }}</div>
        <div class="tools">
            <button class="tool-btn" @click="downloadTemplate">ä¸‹è½½æ¨¡æ¿</button>
            <button class="tool-btn primary" @click="triggerUpload">ğŸ“‚ å¯¼å…¥é¢˜åº“</button>
            <button class="tool-btn" @click="resetDefault">â†» é‡ç½®</button>
            <input type="file" ref="fileInput" style="display: none" accept=".json" @change="handleFileLoad">
        </div>
    </div>

    <div class="content">
        <div v-if="sentenceList.length === 0" style="color: #999; margin-top: 50px;">
            æš‚æ— å¥å­ï¼Œè¯·ç‚¹å‡»å³ä¸Šè§’å¯¼å…¥
        </div>

        <template v-else>
            <div class="chinese">{{ currentSentence.cn }}</div>
            <div class="phonetic">{{ currentSentence.phonetic }}</div>

            <div class="sentence-area">
                <template v-for="(wordObj, index) in currentWordsData" :key="index">
                    <div class="word-wrapper" :style="{ width: getTextWidth(wordObj.correct) + 'px' }">
                        <div class="ghost-text" 
                             :class="{ 'show': isPeeking || (isPeekingSingle && index === focusedIndex) }">
                            {{ wordObj.correct }}
                        </div>

                        <input 
                            :ref="el => inputRefs[index] = el"
                            type="text" class="word-input"
                            v-model="wordObj.userClick"
                            :class="[
                                checkStatus(index), 
                                { 'peeking': isPeeking || (isPeekingSingle && index === focusedIndex) }
                            ]"
                            autocomplete="off" spellcheck="false"
                            :disabled="isCompleted"
                            @keydown="handleKeydown($event, index)"
                            @input="handleInput($event, index)"
                            @focus="focusedIndex = index"
                        >
                    </div>
                    <span v-if="index === currentWordsData.length - 1" style="font-size: 24px; padding-bottom: 5px; color: #333;">,</span>
                </template>
            </div>

            <div class="success-area">
                <button v-if="isCompleted" class="next-btn" @click="nextScene" ref="nextBtnRef">
                    ç»§ç»­ä¸‹ä¸€ä¸ª â†’
                </button>
            </div>
        </template>
    </div>

    <div class="mobile-controls">
        <button class="m-btn" @click="prevScene">â† ä¸Šå¥</button>
        <button class="m-btn" @click="playAudio">ğŸ”Š è¯»éŸ³</button>
        <button class="m-btn" 
            @touchstart.prevent="startPeekSingle" 
            @touchend.prevent="endPeekSingle"
            @mousedown="startPeekSingle" 
            @mouseup="endPeekSingle"
        >ğŸ’¡ æç¤ºè¯</button>
        <button class="m-btn peek-btn" 
            @touchstart.prevent="startPeek" 
            @touchend.prevent="endPeek"
            @mousedown="startPeek" 
            @mouseup="endPeek"
        >ğŸ‘€ æŒ‰ä½çœ‹</button>
        <button class="m-btn" @click="nextScene">ä¸‹å¥ â†’</button>
    </div>

    <div class="footer">
        <div><span class="key-btn">Space</span> æŒ‰ä½çœ‹ç­”æ¡ˆ</div>
        <div><span class="key-btn">Tab</span> æç¤ºå½“å‰è¯</div>
        <div><span class="key-btn">Ctrl+P</span> æ’­æ”¾</div>
        <div><span class="key-btn">Ctrl+â†/â†’</span> åˆ‡æ¢</div>
    </div>
</div>

<script>
    const { createApp, ref, computed, nextTick, onMounted, watch } = Vue;

    // é»˜è®¤å¤‡ç”¨æ•°æ®
    const DEFAULT_DATA = [
        { cn: "æœ€ç³Ÿç³•çš„æ˜¯ï¼Œ", en: "Worst of all", phonetic: "/wÉœËrst/ /ÊŒv/ /É”Ël/" },
        { cn: "æ€»è€Œè¨€ä¹‹ï¼Œ", en: "All in all", phonetic: "/É”Ël/ /Éªn/ /É”Ël/" }
    ];

    createApp({
        setup() {
            const sentenceList = ref([]);
            const currentIndex = ref(0);
            const isPeeking = ref(false);       // ç©ºæ ¼å…¨æ˜¾
            const isPeekingSingle = ref(false); // Tabå•æ˜¾
            const isCompleted = ref(false); 
            const inputRefs = ref([]);
            const nextBtnRef = ref(null);
            const currentWordsData = ref([]);
            const fileInput = ref(null);
            const focusedIndex = ref(0);

            // --- æ ¸å¿ƒï¼šè‡ªåŠ¨ä»æœåŠ¡å™¨åŠ è½½ data.json ---
            const loadData = async () => {
                let loadedFromServer = false;
                try {
                    const response = await fetch('./data.json?t=' + new Date().getTime());
                    if (response.ok) {
                        const json = await response.json();
                        if (Array.isArray(json) && json.length > 0) {
                            sentenceList.value = json;
                            loadedFromServer = true;
                        }
                    }
                } catch (e) { console.log("æœ¬åœ°æ¨¡å¼"); }

                if (!loadedFromServer) {
                    const storedData = localStorage.getItem('english_practice_data');
                    if (storedData) {
                        try { sentenceList.value = JSON.parse(storedData); } 
                        catch(e) { sentenceList.value = [...DEFAULT_DATA]; }
                    } else {
                        sentenceList.value = [...DEFAULT_DATA];
                    }
                }

                const storedIndex = localStorage.getItem('english_practice_index');
                if (storedIndex) {
                    const idx = parseInt(storedIndex);
                    if (idx < sentenceList.value.length) currentIndex.value = idx;
                }
                initSentence();
            };

            const saveData = () => {
                localStorage.setItem('english_practice_data', JSON.stringify(sentenceList.value));
            };
            
            watch(currentIndex, (newVal) => {
                localStorage.setItem('english_practice_index', newVal);
            });

            // --- é€»è¾‘æ§åˆ¶ ---
            const initSentence = () => {
                if (sentenceList.value.length === 0) return;
                isCompleted.value = false;
                const words = sentenceList.value[currentIndex.value].en.split(' ');
                currentWordsData.value = words.map(w => ({ correct: w, userClick: '' }));
                nextTick(() => { if(inputRefs.value[0]) inputRefs.value[0].focus(); });
                setTimeout(() => { playAudio(); }, 500);
            };

            const currentSentence = computed(() => {
                return sentenceList.value[currentIndex.value] || { cn: '', en: '', phonetic: '' };
            });

            // ç§»åŠ¨ç«¯å­—ä½“é€‚é…ï¼šæ‰‹æœºä¸Šå•è¯ä¸è¦å¤ªå®½
            const getTextWidth = (text) => {
                const base = window.innerWidth < 600 ? 14 : 22; // æ‰‹æœºå­—å·å°ï¼Œå®½åº¦ç³»æ•°å‡å°
                return Math.max(window.innerWidth < 600 ? 40 : 80, (text || '').length * base); 
            };

            const checkStatus = (index) => {
                const item = currentWordsData.value[index];
                if (!item.userClick) return '';
                if (item.correct.toLowerCase().startsWith(item.userClick.toLowerCase())) {
                     return item.userClick.length === item.correct.length ? 'correct' : '';
                }
                return 'error';
            };

            const checkAllCorrect = () => {
                const allCorrect = currentWordsData.value.every(item => 
                    item.userClick.toLowerCase() === item.correct.toLowerCase()
                );
                if (allCorrect) {
                    isCompleted.value = true;
                    // æ”¶èµ·æ‰‹æœºé”®ç›˜ï¼Œè®©ç”¨æˆ·çœ‹åˆ°â€œç»§ç»­â€æŒ‰é’®
                    if (document.activeElement) document.activeElement.blur();
                }
            };

            const handleInput = (e, index) => {
                const val = e.target.value;
                const correct = currentWordsData.value[index].correct;
                if (val.toLowerCase() === correct.toLowerCase()) {
                    if (index < currentWordsData.value.length - 1) {
                        nextTick(() => inputRefs.value[index + 1].focus());
                    } else {
                        checkAllCorrect();
                    }
                }
            };

            const handleKeydown = (e, index) => {
                if (e.code === 'Space') {
                    e.preventDefault(); isPeeking.value = true;
                    const upListener = () => { isPeeking.value = false; window.removeEventListener('keyup', upListener); };
                    window.addEventListener('keyup', upListener);
                    return;
                }
                if (e.key === 'Tab') {
                    e.preventDefault(); isPeekingSingle.value = true;
                    const upListener = () => { isPeekingSingle.value = false; window.removeEventListener('keyup', upListener); };
                    window.addEventListener('keyup', upListener);
                    return;
                }
                if (e.key === 'Backspace' && currentWordsData.value[index].userClick === '') {
                    e.preventDefault(); if (index > 0) inputRefs.value[index - 1].focus();
                }
                if (e.ctrlKey && e.key.toLowerCase() === 'p') { e.preventDefault(); playAudio(); }
                if (e.key === 'Enter') { 
                    if (isCompleted.value) nextScene();
                    else if (index < currentWordsData.value.length - 1) inputRefs.value[index + 1].focus(); // æ‰‹æœºEnterè·³ä¸‹ä¸€ä¸ª
                }
                if (e.ctrlKey && e.key === 'ArrowLeft') { e.preventDefault(); prevScene(); }
                if (e.ctrlKey && e.key === 'ArrowRight') { e.preventDefault(); nextScene(); }
            };

            // --- æŒ‰é’®åŠŸèƒ½ (PC/Mobileé€šç”¨) ---
            const nextScene = () => {
                if (currentIndex.value < sentenceList.value.length - 1) {
                    currentIndex.value++;
                    initSentence();
                } else {
                    alert("ç»ƒä¹ å®Œæˆï¼å³å°†é‡æ–°å¼€å§‹");
                    currentIndex.value = 0;
                    initSentence();
                }
            };

            const prevScene = () => {
                if (currentIndex.value > 0) { currentIndex.value--; initSentence(); }
            };

            const playAudio = () => {
                if (!currentSentence.value.en) return;
                window.speechSynthesis.cancel(); // å…ˆåœæ­¢ä¹‹å‰çš„
                const u = new SpeechSynthesisUtterance(currentSentence.value.en);
                u.lang = 'en-US'; u.rate = 0.9;
                window.speechSynthesis.speak(u);
            };

            // --- ç§»åŠ¨ç«¯è§¦æ§äº‹ä»¶ ---
            const startPeek = () => { isPeeking.value = true; };
            const endPeek = () => { isPeeking.value = false; };
            const startPeekSingle = () => { isPeekingSingle.value = true; };
            const endPeekSingle = () => { isPeekingSingle.value = false; };

            // --- æ–‡ä»¶å¯¼å…¥å¯¼å‡º ---
            const triggerUpload = () => fileInput.value.click();
            const handleFileLoad = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const json = JSON.parse(e.target.result);
                        if (Array.isArray(json)) {
                            sentenceList.value = json;
                            currentIndex.value = 0;
                            saveData();
                            initSentence();
                            alert(`å¯¼å…¥æˆåŠŸ: ${json.length}å¥`);
                        }
                    } catch (err) { alert('æ–‡ä»¶æ ¼å¼é”™è¯¯'); }
                };
                reader.readAsText(file);
                event.target.value = '';
            };
            const downloadTemplate = () => {
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(DEFAULT_DATA, null, 2));
                const a = document.createElement('a');
                a.href = dataStr; a.download = "template.json"; a.click();
            };
            const resetDefault = () => {
                if(confirm('æ¢å¤é»˜è®¤é¢˜åº“ï¼Ÿ')) {
                    sentenceList.value = [...DEFAULT_DATA];
                    currentIndex.value = 0;
                    saveData();
                    initSentence();
                }
            };

            onMounted(() => {
                loadData();
            });

            return {
                sentenceList, currentIndex, currentSentence, currentWordsData, inputRefs, isPeeking, isPeekingSingle, isCompleted, nextBtnRef, fileInput, focusedIndex,
                getTextWidth, checkStatus, handleKeydown, handleInput, nextScene, prevScene, playAudio,
                downloadTemplate, triggerUpload, handleFileLoad, resetDefault,
                startPeek, endPeek, startPeekSingle, endPeekSingle
            };
        }
    }).mount('#app');
</script>
</body>
</html>
